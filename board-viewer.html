_translate<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-slider/paper-slider.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../iron-ajax/iron-request.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-icons/maps-icons.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<script src="../es6-shim/es6-shim.min.js"></script>
<script src="../mustache.js/mustache.min.js"></script>
<script src="../markdown-it/dist/markdown-it.js"></script>

<script src="svg-injector.js"></script>

<!--
`<board-viewer>` Provides an interactive hardware board viewer.

There are two functional modes the board-viewer operates in:

1. Interactive. All pins / components are enabled, but none are visible. The
   user can hover around the board to see pins and their related and/or
   connected pins, and to activate (click/tap) or select (CTRL+click/tap)
2. Selection. Interaction is limited to a specific set of pins and their related/
   connected pins. If disable-shadow is not set, a shadow will obscure all non-active
   pins.

Example:

    <board-viewer
      enable-drag
      enable-zoom
      selected="I2C,JTAG,J6"
      board="quark_mcu_dev_kit_d2000">
    </board-viewer>

The above will load the `quark_mcu_dev_kit_d2000` out of the `boards/`,
and start by highlighting the graphic components with keywords or ids matching
`I2C`, `JTAG`, or `J6`.

See [board-explorer](https://github.com/board-explorer/board-explorer) for
information on creating board files.

If any are active, only the active ones are active

@demo demo/index.html Simple demo showing a statically loaded view.
-->

<dom-module id='board-viewer'>
  <template>
  <style include="iron-flex iron-flex-alignment iron-positioning">
    /* The board-viewer only uses div and img; reset those elements
     * to their initial settings within the .board-viewer namespace */
    :host {
      display: block;
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      background-color: #23ccfc;
      z-index: 0;
      overflow: hidden !important;
    }

    :host div {
      overflow: visible;
      box-sizing: content-box;
    }

    #viewer {
      cursor: default;
    }

    :host[enable-drag] #viewer {
      cursor: move;
      cursor: -webkit-grab;
      cursor: -moz-grab;
      cursor: grab;
    }

    .drag {
      cursor: move !important;
      cursor: -webkit-grabbing !important;
      cursor: -moz-grabbing !important;
      cursor: grabbing !important;
    }

    #svg,
    #shadow,
    #filters {
      display: inline-block;
      position: absolute;
      top: 0px;
      left: 0px;
    }

    #svg {
      pointer-events: none;
    }

    #filters {
      z-index: 100;
    }

    #shadow {
      right: 0px;
      bottom: 0px;
      opacity: 0.5;
      z-index: 50; /* Above the board (0), below filters (100) and pins (200) and controls (300) */
      pointer-events: none;
    }

    #shadow.hidden {
      opacity: 0;
    }

    #filters > div {
      position: absolute;
      opacity: 1;
      border-width: 2px;
      border-style: solid;
      padding: 0.1em;
      box-sizing: content-box;
      transition: opacity 0.25s linear;
      border-radius: 0.25rem;
      transform: translate(-50%, -50%);
      cursor: pointer;
      pointer-events: none;
    }

    #filters > div[pin] {
      z-index: 200;
    }

    /* Interactive, if not alwaysVisible, are transparent when not hovered */
    #filters > div.interactive {
      pointer-events: all;
      opacity: 0;
    }

    /* Hovering over interactive elements makes them full bright */
    #filters > div.interactive:hover,
    #filters > div.interactive.alwaysVisible:hover {
      opacity: 1;
    }

    /* alwaysVisible are half dim when not highlighted */
    #filters > div.alwaysVisible,
    #filters > div.interactive.alwaysVisible {
      opacity: 0.5;
    }

    /* Non-interactive and alwaysVisible are always bright */
    #filters > div.alwaysVisible:not(.interactive) {
      opacity: 1;
    }

    #board {
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      padding: 0;
      margin: 0;
      width: 100%;
      height: 100%;
      position: absolute;
      z-index: 0;
      pointer-events: none;
    }

    #viewer {
      position: relative;
      box-sizing: border-box;
      height: 100%;
      width: 100%;
    }

    #container {
      position: absolute;
      display: inline-block;
      box-sizing: border-box;
      top: 0px;
      left: 0px;
      height: 100%;
      width: 100%;
    }

    #controls {
      margin-right: 1em;
      color: #bdbdbd;
      --iron-icon-fill-color: #bdbdbd;
    }

    #controls * {
      z-index: 300; /* Above filters (100) and pins (200) */
      cursor: pointer;
    }
  </style>

  <div id="viewer">
    <iron-request id="boards"></iron-request>
    <iron-ajax auto handle-as="json" id="board"></iron-ajax>

    <canvas id="shadow"></canvas>

    <div id="container">
      <div id="svg"><!-- holds the created IMG that SVGInjector() uses--></div>
      <div id="filters"></div>
    </div>

    <div id="controls" class="horizontal layout end-justified center">
      <template is="dom-if" if="[[enableZoom]]">
        <paper-slider id="zoomControl"
          step="0.1" min="0" max="2" value="0"
          on-immediate-value-changed="_onZoomChanged">
        </paper-slider>
      </template>
      <template is="dom-if" if="[[disableAutoResize]]">
        <iron-icon icon="maps:zoom-out-map" on-tap="_zoomToFit"></iron-icon>
      </template>
    </div>
  </div>
</template>

<script>
"use strict";

Polymer({
  is: "board-viewer",
  properties: {
    /** When set, board will not resize with it's client region. */
    disableAutoResize: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },
    /** Whether the zoom operations are available / control is visible. */
    enableZoom: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },
    /** Whether dragging the board is enabled. */
    enableDrag: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /** The board name currently loaded (or loading). This will be loaded
     * out of the *basePath* directory as *basePath/board* */
    board: {
      type: String,
      readOnly: true,
      notify: true
    },
    /** The zoom level of the board. Minimum: 0.5, Maximum: 1.5 */
    zoom: {
      type: Number,
      value: 0,
      notify: true
    },
    /** Default scale for the board. 1.0 fills the viewport (while maintaining
     * aspect ratio.) */
    defaultScale: {
      type: Number,
      value: 0.8
    },
    /** Base path for loading meta-data files */
    basePath: {
      type: String,
      value: ""
    },
    /** Comma separated list of refdes, keywords, and groups to show.
     * For example: "JTAG,I2C,J6" */
    selected: {
      type: String,
      notify: true,
      value: []
    },
    /** Disable the shadow while in Active mode */
    disableShadow: {
      type: Boolean,
      value: false
    },
    _translate: {
      type: Object,
      value: {
        x: 0,
        y: 0
      }
    },
    _filters: { /* Internal copy of filters */
      type: Array,
      value: []
    },
    _origin: { /* Used for drag operations */
      type: Object,
      value: { x: 0, y: 0 }
    },
    _boardData: {
      type: Array,
      value: []
    },
    _boardElements: {
      type: Array,
      value: []
    },
    _categories: {
      type: Array,
      value: []
    },
    _svg: {
      type: Object
    },
    _svgElements: {
      type: Array,
      value: []
    },
    _firstResize: { /* Has the first resize event been triggered */
      type: Boolean,
      value: true
    },
    scaling: {
      type: Boolean,
      value: false
    },
    trackPoints: {
      type: Array,
      value: []
    }
  },

  observers: [
    "_onEnableDrag(enableDrag)",
    "_onEnableZoom(enableZoom)",
    "_mapSvgToBoardData(_svg, _boardData)",
    "_onSelectedChanged(selected, _boardData)",
    "_onDisableAutoResizeChanged(disableAutoResize)",
    "_onDisableShadowChanged(disableShadow)"
  ],

  behaviors: [
    /* @polymerBehavior Polymer.IronResizableBehavior */
    Polymer.IronResizableBehavior
  ],

  listeners: {
    "tap": "_onTap",
    "iron-resize" : "resize",
    "touchmove": "_onPinch",
    "wheel": "_onScroll",
    "board.response": "_boardLoaded",
    "board.error": "_boardLoadError",
    "keydown": "_keyDown",
    "keyup": "_keyUp"
  },

  _keyDown: function(event) {
    console.log("Down: " + event);
  },

  _keyUp: function(event) {
    console.log("Up: " + event);
  },

  _onDisableShadowChanged: function(disableShadow) {
    this._renderShadow();
  },

  _onTap: function(event) {
    /* If the board-viewer is tapped on, clear the selected items */
    this.selected = [];
  },

  _zoomToFit: function() {
    this._firstResize = true;
    this.$$('#zoomControl').value = 0;
    this.resize();
  },

  _onDisableAutoResizeChanged: function(disableAutoResize) {
    if (!disableAutoResize) {
      this.resize();
    }
  },

  _onScroll: function(event) {
    /* Getting zoom-bar. */
    var zoomControl = this.$$('#zoomControl');
     /* Inverted aim. */
    if (event.deltaY < 0) {
      this.zoom = Math.max(Math.min(this.zoom + 0.1, 2.0), 0);
    } else {
      this.zoom = Math.max(Math.min(this.zoom - 0.1, 2.0), 0);
    }
     /* Adjusting bar progres to current zoom value. */
    zoomControl.value = this.zoom;
    this._onBoardZoom(this._svg, this.zoom);
  },

  setSelected: function(selected) {
    if (!Array.isArray(selected)) {
      selected = [ selected ];
    }
    this.selected = selected.slice();
  },

  _onPinch: function(event) {
    /* Detecting single or none touches: */
    if (event.changedTouches.length < 2) {
      // When scaling is on, then end.
      if (this.scaling) {
        this.trackPoints = [];
        this.scaling = false;
      } else {
        /* A single touch, returning track listener to defult state. */
        this.enableDrag ? this.listen(this, 'track', '_onTrack') : this.unlisten(this, 'track', '_onTrack');
      }
    } else {
      if (!this.scaling && event.changedTouches.length == 2) {
        /* When a couple of touches are detected, start scaling. */
        /* forcing to disable track listener while scaling. */
        this.unlisten(this, 'track', '_onTrack');
        this.scaling = true;
      }
    }

    /* Maths while scaling: */
    if (this.scaling) {
      /* Calculating distance between finger touches. */
      var dist = Math.sqrt(
        Math.pow(event.changedTouches[0].clientX - event.changedTouches[1].clientX, 2) +
        Math.pow(event.changedTouches[0].clientY - event.changedTouches[1].clientY, 2)
      );
      /* Storing distances to compare. */
      this.trackPoints.push(dist);
      /* We need to compare the last two distances stored to determine if,
      is a zoom in or zoom out. */
      if (this.trackPoints.length >= 2) {
        var finalDistance = this.trackPoints[this.trackPoints.length - 1];
        var initialDistance = this.trackPoints[this.trackPoints.length - 2];
        var zoomControl = this.$$('#zoomControl');
        /* Pinch is growing, then zoom in. */
        if (finalDistance > initialDistance) {
          this.zoom = Math.max(Math.min(this.zoom + 0.1, 2.0), 0);
        } else {
          /* Pinch is getting smaller, then zoom out. */
          this.zoom = Math.max(Math.min(this.zoom - 0.1, 2.0), 0);
        }
        zoomControl.value = this.zoom;

        this._onBoardZoom(this._svg, this.zoom);
      }
    }
  },

  _onSelectedChanged: function(selected) {
    if (typeof selected === "string") {
      selected = selected.split(",");
    }
    if (!Array.isArray(selected)) {
      selected = [ selected ];
    }

    /* If no items are actively selected, turn all items into interactive
     * hoverable targets */
    if (selected.length == 0) {
      console.log("No selection -- adding all items as interactive");

      this.removeFilter("selected");
      this.removeFilter("selected-connected");
      this.removeFilter("selected-related");

      /* Turn on the 'Everything' interactive filters;
       * Pins will be Green
       * Components will be Cyan */
      this.addFilter("Pins", { type: "PIN", pattern: "*" }, {
        color: "#00ffff",
        alwaysVisible: false
      });

      this.addFilter("Components", { type: "COMPONENT", pattern: "*" }, {
        color: "#00ffff",
        alwaysVisible: false
      });

      return;
    }

    if (!this.multiSelectActive) {
      this.removeFilter("Pins");
      this.removeFilter("Components");
    }

    this.addFilter("selected", selected, {
      color: "#ffff00",
      interactive: true,
      alwaysVisible: true
    });

    var connected = [], related = [];
    selected.forEach(function(filter) {
      var item = this.findComponent(filter);
      if (!item) {
        return;
      }

      /* Walk through the list of connected elements; if not in the list of
       * connections, add it */
      if (!item.connected) {
        item.connected = [];
      }
      for (var i = 0; i < item.connected.length; i++) {
        if (connected.indexOf(item.connected[i]) == -1) {
          connected.push(item.connected[i]);
        }
      }

      /* Walk through the list of connected elements; if not in the list of
       * connections, add it */
       if (!item.related) {
         item.related = [];
       }
      for (var i = 0; i < item.related.length; i++) {
        if (related.indexOf(item.related[i]) == -1) {
          related.push(item.related[i]);
        }
      }
    }.bind(this));

    this.addFilter("selected-connected", connected, {
      color: "#ff8000",
      alwaysVisible: true,
      interactive: true
    });

    this.addFilter("selected-related", related, {
      color: "#00ff00",
      alwaysVisible: true,
      interactive: true
    });
  },

  /* This needs to be connected to the zoom slider control (currently not
   * implemented) */
  _onZoomChanged: function(event) {
    this.zoom = Math.max(Math.min(event.detail.value, 2.0), 0);
    this.resize();
  },

  _onBoardMove: function(x, y) {
    /* Can get called during initialization before DOM stamped */
    var container = this.$.container;
    if (!container) {
      return;
    }
    container.style.top = y + 'px';
    container.style.left = x + 'px';

    this._renderShadow();

    Polymer.dom.flush();
  },

  _onBoardZoom: function(svg, zoom) {
    if (!svg) {
      return;
    }

    zoom = this.scale + this.scale * zoom;

    var transform = '', style = '', bb;

    /* Work around Firefox issue #612118; getBBox() throws an exception if
     * the SVG is not being rendered */
    try {
      bb = svg.getBBox();
    } catch (_) {
      return;
    }

    transform = "translate("
      + -bb.width * zoom * 0.5 + "px,"
      + -bb.height * zoom * 0.5 + "px)";
    style += '-webkit-transform:' + transform + ';';
    style += '-ms-transform:' + transform + ';';
    style += '-moz-transform:' + transform + ';';
    style += 'transform:' + transform + ';';
    style += 'width: ' + bb.width * zoom + 'px;';
    style += 'height: ' + bb.height * zoom + 'px;';

    this.$.svg.style.cssText = style;
    Polymer.dom.flush();

    /* Unhide the SVG itself; we hide it when the board is being loaded. We
     * don't show it until now because the style for the parent (this.$.svg)
     * would have it in the wrong spot */
    this._svg.style.width = "100%";
    this._svg.style.height = "100%";
    this._svg.style.visibility = 'visible';

    this._calculateSVGElements();
    this._filters.forEach(this._populateFilter, this);
    this._renderShadow();
  },

  _calculateSVGElements: function() {
    var offset = this.getBoundingClientRect();

    this._svgElements.forEach(function(svgItem) {
      var rect = svgItem.el.getBoundingClientRect();
      svgItem.rect = {
        top: rect.top + rect.height * 0.5 - this._translate.y - offset.top + 'px',
        left: rect.left + rect.width * 0.5 - this._translate.x - offset.left + 'px',
        width: rect.width + 'px',
        height: rect.height + 'px'
      }
    }, this);
  },

  _onEnableDrag: function(enabled) {
    if (!enabled) {
      this.unlisten(this, 'track', '_onTrack');
    } else {
      this.listen(this, 'track', '_onTrack');
    }
  },

  _onEnableZoom: function(enabled) {
    if (!enabled) {
      if (this.$$('#zoomControl')) {
        this.$$('#zoomControl').setAttribute('disabled', '');
      }
      this.unlisten(this, 'touchmove', '_onPinch');
      this.unlisten(this, 'wheel', '_onScroll');
    } else {
      if (this.$$('#zoomControl')) {
        this.$$('#zoomControl').removeAttribute('disabled');
      }

      this.listen(this, 'touchmove', '_onPinch');
      this.listen(this, 'wheel', '_onScroll');
    }
  },

  _onTrack: function(event) {
    this.tapTarget = null;
    event.preventDefault();

    if (event.detail.state == 'start') {
      event.target.classList.add('drag');
      this.$.viewer.classList.add('drag');
      this._origin = {
        x: this._translate.x,
        y: this._translate.y
      }
    }

    this._translate.x = this._origin.x + event.detail.dx;
    this._translate.y = this._origin.y + event.detail.dy;
    this._onBoardMove(this._translate.x, this._translate.y);

    if (event.detail.state == 'end') {
      Array.prototype.forEach.call(this.querySelectorAll('.drag'),
        function(el) {
        el.classList.remove('drag');
      });
      this._origin.x = this._translate.x;
      this._origin.y = this._translate.y;
    }
  },

  /* Look up the item corresponding to the provided
   * refdes
   *
   * @param {String} refdes Reference designator to look up, for example J6Pin4
   * @returns {Object}
   */
  findComponent: function(refdes) {
    if (!refdes) {
      return null;
    }

    var parts = refdes.split("Pin"),
      isPin = parts.length == 2,
      component = null;

    /* Look up the component first */
    for (var i = 0; i < this._boardData.length; i++) {
      if (this._boardData[i].refdes == parts[0]) {
        component = this._boardData[i];
        break;
      }
    }

    if (!component) {
      return null;
    }

    /* If the inbound refdes isn't a pin, return the component */
    if (!isPin) {
      return component;
    }

    /* If no pins are on this component, we can't find the requested pin,
     * so return null */
    if (!component.pins) {
      return null;
    }

    /* Look for the pin in this component */
    for (var i = 0; i < component.pins.length; i++) {
      if (component.pins[i].refdes == refdes) {
        return component.pins[i];
      }
    }

    /* No matches anywhere... return null */
    return null;
  },

  /** Load a new board.
   *
   * @param {String} board The name of the board to load.
   */
  loadBoard: function(board) {
    /* Do not attempt to re-load the same board multiple times */
    if (this._board == board) {
      return;
    }

    this._board = board;

    /* Delete any children of the svg container */
    var element = this.$.svg;
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }

    this._svg = null;
    this._boardData = [];
    this._categories = [];

    /* Remove all the filters for the current board */
    this.removeFilter();
    this._renderShadow();

    this._setBoard("");

    if (!board || board == '') {
      return;
    }

    console.log('Loading ' + board + ' into board-viewer.');
    var url = this.basePath + "boards/" + this._board + "/board.json";
    if (this.$.board.url == url) {
      this.$.board.generateRequest();
    } else {
      this.$.board.url = url;
    }
  },

  _boardLoaded: function(event) {
    console.log("Parsing " + this._board);

    var image = document.createElement('img');

    image.style.visibility = 'hidden';

    /* SVGInjector replaces 'image' with the svg it constructs
     *
     * Add the image to the document body; if we add it to the board-viewer,
     * and the board-viewer is currently 'display: none', the SVG does not
     * get setup correctly. */
    document.body.appendChild(image);

    /* Do not inject the SVG until after the SVG has completed
     * loading into the main image, otherwise there is a race
     * c_onDition which can result in the SVG never showing up */
    image.onload = function(board) {
      if (board != this._board) {
        console.log("Discarding load of older board {IMG}.");
        return;
      }

      SVGInjector(image, {
        evalScripts: 'once',
        each: function(svg) {
          if (board != this._board) {
            console.log("Discarding load of older board {SVG}.");
            return;
          }

          if (typeof svg == 'string') {
            console.log('ERROR: ' + svg);
            return;
          }

          /* If this board is already loaded by a concurrent load instance,
           * don't parse it again. This sequence could occur if multiple
           * loadBoard() calls are made rapidly switching between a two
           * boards while the assets from one are still loading or being
           * parsed. loadBoard(A), then before A finishes loading, loadBoard(B)
           * then loadBoard(A) again. Two SVGLoaders could fire concurrently;
           * only one should be processed. */
          if (this.$.svg.firstChild &&
            this.$.svg.firstChild.getAttribute('board') == this._board) {
            console.log("Not re-loading/parsing the same board more than once");
            return;
          }

          Polymer.dom.flush();

          svg.setAttribute('board', this._board);
          /* Trim off any whitespace/viewbox padding from the SVG
           * asset */
          var bb = svg.getBBox();
          svg.setAttribute('viewBox', bb.x + ' ' + bb.y + ' ' + bb.width + ' ' + bb.height);
          svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

          this.zoom = 0;
          this.scale = 1;
          this._translate.x = this.offsetWidth * 0.5;
          this._translate.y = this.offsetHeight * 0.5;

          /* Caches the _original (unscaled or translated) bounding rectangle
          * for use when constructing new highlight rectangles */
          this._svgElements = [];

          Array.prototype.forEach.call(svg.querySelectorAll('[id^="BV_"]'),
            function(el) {
            this._svgElements.push({
              refdes: el.id.replace(/^BV_/, ''),
              el: el
            });
          }, this);

          console.log("Binding board image to the DOM");

          Polymer.dom.flush();
          this.updateStyles();

          this.$.svg.appendChild(svg);

          this._firstResize = true; /* Re-trigger a scaling resize */

          /* Set this._svg at the end so _mapSvgToBoardData doesn't trigger
           * until the DOM is populated with the SVG */
          this._svg = svg;

          /* If there are no selected items when the board finishes loading,
           * add the default "no selection, everything interactive" filters */
          if (!this.selected || !this.selected.length) {
            /* Turn on the 'Everything' interactive filters;
             * Pins will be Green
             * Components will be Cyan */
            this.addFilter("Pins", { type: "PIN", pattern: "*" }, {
              color: "#00ffff",
              alwaysVisible: false
            });

            this.addFilter("Components", { type: "COMPONENT", pattern: "*" }, {
              color: "#00ffff",
              alwaysVisible: false
            });
          }
        }.bind(this)
      });
    }.bind(this, this._board);

    var data = this.$.board.lastResponse;

    /* For now we only support one side of the board -- front. */
    image.src = "boards/" + this._board + "/" + data.views.front.image;

    var categoryList = data.categories;
    data = data.views.front.components;
    var components = [];

    for (var key in data) {
      if (typeof data[key] != 'object') {
        console.log("Skipping non object '" + key + ".'");
        continue;
      }

      /* Create "smart" defaults based on normal structures */
      var component = Object.assign({
        refdes: key,
        readable: key,
        name: key,
        connected: [],
        related: []
      }, data[key]);

      /* Do not let the JSON override the type */
      component.type = "component";

      if (component.keywords) {
        for (var i = 0; i < component.keywords.length; i++) {
          component.keywords[i] = component.keywords[i].toUpperCase();
        }
      }

      components.push(component);

      if ("pins" in data[key]) {
        component.pins = [];
        for (var id in data[key].pins) {
          var isJumper = component.keywords && (component.keywords.indexOf("JUMPER") != -1),
            readable;

          if (isJumper) {
            readable = component.refdes + " Pins " + id.substr(0, 1) + "-" + id.substr(1, 1);
          } else {
            readable = component.refdes + " Pin " + id;
          }

          /* Create "smart" defaults based on normal structures */
          var item = Object.assign({
            refdes: component.refdes + "Pin" + id,
            readable: readable,
            name: readable,
            component: component.refdes,
            connected: [],
            related: []
          }, data[key].pins[id]);

          /* Do not let the JSON override the type */
          item.type = "pin";

          if (item.keywords) {
            for (var i = 0; i < item.keywords.length; i++) {
              item.keywords[i] = item.keywords[i].toUpperCase();

              /* Ensure that the parent component is the superset of all
               * keywords of all contained pins */
              if (!component.keywords) {
                component.keywords = [];
              }
              if (component.keywords.indexOf(item.keywords[i]) == -1) {
                component.keywords.push(item.keywords[i]);
              }
            }

            item.keywords = item.keywords.sort();
          }

          if (component.keywords) {
            component.keywords = component.keywords.sort();
          }

          component.pins.push(item);
        }
      }
    }

    /* Set _boardData first since findComponent is used when configuring
     * categories. */
    this._boardData = components;
    /* Rewalking components to find implicit relationships */
    for (var i = 0; i < this._boardData.length; i ++) {
      var implicitRelations = this.getImplicitRelations(this._boardData[i].refdes);
      this._boardData[i].related = implicitRelations.related;
      this._boardData[i].connected = implicitRelations.connected;
      if (this._boardData[i].pins) {
        for (var j = 0; j < this._boardData[i].pins.length; j ++) {
          implicitRelations = this.getImplicitRelations(this._boardData[i].pins[j].refdes);
          this._boardData[i].pins[j].related = implicitRelations.related;
          this._boardData[i].pins[j].connected = implicitRelations.connected;
        }
      }
    }

    var categories = [];
    if (categoryList) {
      if (!Array.isArray(categoryList)) {
        console.warn("'categories' should be an array of { name: string, list: []}");
      } else {
        categoryList.forEach(function(category, index) {
          var entry = {
            list: []
          };
          if (!category.name || typeof category.name !== 'string') {
            console.warn("'name' is missing or not a string in category #" + index);
            return;
          }
          if (!category.list || !Array.isArray(category.list)) {
            console.warn("'list' is missing or not an array in category #" + index);
            return;
          }

          entry.name = category.name;
          entry.slug = escape(category.name.toLowerCase().replace(/[^\w ]+/g,'').replace(/ +/g,'-'));

          var keywords = [];
          this.getKeywords(function(results) {
            keywords = results;
          });

          category.list.forEach(function(term) {
            var item = this.findComponent(term);
            if (!item && keywords.indexOf(term) == -1) {
              console.warn("'" + term + "' listed in category #" + index + " does not exist.");
              return;
            }
            entry.list.push(term);
          }.bind(this));

          categories.push(entry);
        }.bind(this));
      }
    }

    this._categories = categories;
    this._setBoard(this._board);
  },

  _boardLoadError: function(event) {
    console.log("Unable to load boards/" + this._board + ".json");
  },

  hasFilter: function(name) {
    for (var i = 0; i < this._filters.length; i++) {
      if (this._filters[i].name == name) {
        return true;
      }
    }

    return false;
  },

    getImplicitRelations: function (refdes) {
    /* Initial state for a give refdes */
    var relatedRefdes = {
      connected: [],
      related: []
    };
    /* Walk backward and find if refdes is within a connected/related set,
     * in other component. */
    relatedRefdes = this._searchBackReferences(refdes, relatedRefdes);
    /* If we found a previus references we need to still rewalking behind,
     * and search foward for each reference added. */

    /* Rewalking backward connected components */
    var i = 0;
    do {
      relatedRefdes = this._searchBackReferences(relatedRefdes.connected[i], relatedRefdes);
      relatedRefdes = this._searchAheadReferences(relatedRefdes.connected[i], relatedRefdes);
      i++;
    } while(i < relatedRefdes.connected.length);

     /* Rewalking backward related components */
    var i = 0;
    do {
      relatedRefdes = this._searchBackReferences(relatedRefdes.related[i], relatedRefdes);
      relatedRefdes = this._searchAheadReferences(relatedRefdes.related[i], relatedRefdes);
      i++;
    } while(i < relatedRefdes.related.length);

    /* Walking foward */
    var component = this.findComponent(refdes);
    var connectedRels =  component.connected;
    var relatedRels = component.related;
    var currentRelatedIndex = relatedRefdes.related.length;
    var currentConnectedIndex = relatedRefdes.connected.length;

    /* If we have an explicit set of connected components */
    if (connectedRels) {
      /* Appending inital set, to the previous references if there are not,
       * already in the array. */
      for (var i = 0; i < connectedRels.length; i++) {
        if (relatedRefdes.connected.indexOf(connectedRels[i]) == -1
          && refdes != connectedRels[i]) {
          relatedRefdes.connected.push(connectedRels[i]);
        }
      }
      /* We start to search from the last position stored for connected array */
      i = currentConnectedIndex;
      /* If we found more references we need to still rewalking ahead,
       * and search backward for each reference added. */
      do {
        relatedRefdes = this._searchBackReferences(relatedRefdes.connected[i], relatedRefdes);
        relatedRefdes = this._searchAheadReferences(relatedRefdes.connected[i], relatedRefdes);
        i++;
      } while(i < relatedRefdes.connected.length);
    }

    /* If we have an explicit set of related components */
    if (relatedRels) {
      /* Appending inital set, to the previous references if there are not,
       * already in the array. */
      for (var i = 0; i < relatedRels.length; i++) {
        if (relatedRefdes.related.indexOf(relatedRels[i]) == -1 &&
          refdes != relatedRels[i]) {
          relatedRefdes.related.push(relatedRels[i]);
        }
      }
      /* We start to search from the last position stored for related array */
      i = currentRelatedIndex;
      /* If we found more references we need to still rewalking ahead,
       * and search backward for each reference added. */
      do {
        relatedRefdes = this._searchBackReferences(relatedRefdes.related[i], relatedRefdes);
        relatedRefdes = this._searchAheadReferences(relatedRefdes.related[i], relatedRefdes);
        i++;
      } while(i < relatedRefdes.related.length);
    }

    return relatedRefdes;
  },

  _searchBackReferences: function(refdes, currentState) {
    var components =  this._boardData, relatedRefdes = currentState;
    for (var i = 0; i < components.length; i++) {
      /* We get the connected and related set's to start find the refdes within */
      var connected = components[i].connected;
      var related = components[i].related;
      /* Adding connected if there are not in the cuurent state */
      if (connected && connected.indexOf(refdes) != -1 &&
        relatedRefdes.connected.indexOf(components[i].refdes) == -1) {
        relatedRefdes.connected.push(components[i].refdes);
      }
      /* Adding related if there are not in the cuurent state */
      if (related && related.indexOf(refdes) != -1 &&
        relatedRefdes.related.indexOf(components[i].refdes) == -1) {
        relatedRefdes.related.push(components[i].refdes);
      }
      /* If the component have pins, do the same on them */
      if (components[i].pins) {
        var pins =  components[i].pins;
        for (var j = 0; j < pins.length; j++) {
          connected = pins[j].connected;
          related = pins[j].related;
          if (connected && connected.indexOf(refdes) != -1 &&
            relatedRefdes.connected.indexOf(pins[j].refdes) == -1) {
            relatedRefdes.connected.push(pins[j].refdes);
          }
          if (related && related.indexOf(refdes) != -1 &&
            relatedRefdes.related.indexOf(pins[j].refdes) == -1) {
            relatedRefdes.related.push(pins[j].refdes);
          }
        }
      }
    }
    return relatedRefdes;
  },

  _searchAheadReferences: function(refdes, currentState) {
    var component = this.findComponent(refdes), relatedRefdes = currentState;
    /* Only if we found the component */
    if (component) {
      /* We get the connected and related set's to start find the refdes within */
      var connected = component.connected;
      var related = component.related;
      /* Adding connected if there are not in the cuurent state */
      if (connected) {
        for (var i = 0; i < connected.length; i++) {
          if (relatedRefdes.connected.indexOf(connected[i]) == -1){
            relatedRefdes.connected.push(connected[i]);
          }
        }
      }
       /* Adding related if there are not in the cuurent state */
      if (related) {
        for (var i = 0; i < related.length; i++) {
          if (relatedRefdes.related.indexOf(related[i]) == -1){
            relatedRefdes.related.push(related[i]);
          }
        }
      }
      /* If the component have pins, do the same */
      if (component.pins) {
        var pins =  component.pins;
        for (var j = 0; j < component.pins.length; j++) {
          connected = pins.connected;
          related = pins.related;
          if (connected) {
            for (var i = 0; i < connected.length; i++) {
              if (relatedRefdes.connected.indexOf(connected[i]) == -1){
                relatedRefdes.connected.push(connected[i]);
              }
            }
          }
          if (related) {
            for (var i = 0; i < related.length; i++) {
              if (relatedRefdes.related.indexOf(related[i]) == -1){
                relatedRefdes.related.push(related[i]);
              }
            }
          }
        }
      }
    }
    return relatedRefdes;
  },

  /** Get the list of component categories.
   */
  getCategories: function() {
    return this._categories;
  },

  /** Add a filter.
   *
   * @param {String} name The name of the filter.
   * @param {Object} match Parameters for the filter match criteria.
   * @param {Object} options Style and interaction attributes for this filter.
   */
  addFilter: function(name, match, options) {
    if (!this._filters) {
      this._filters = [];
    }

    for (var i = 0; i < this._filters.length; i++) {
      if (this._filters[i].name == name) {
        this.removeFilter(name);
        break;
      }
    }

    /* Assign default values to the options */
    options = Object.assign({
      color: "#00ff00",
      alwaysVisible: false,
      interactive: true
    }, options || {});

    if (!this.filterIndex) {
      this.filterIndex = 1;
    }

    if (typeof match === "string") {
      match = {
        type: "ALL",
        pattern: match
      }
    }

    /* If the match is an array, we can assume that is a LIST type filter */
    if (Array.isArray(match)) {
      match = {
        type: "LIST",
        pattern: match
      }
    }

    /* If the match is an object and have the property list */
    if (typeof match === "object" && match.list) {
      match = {
        type: "CATEGORY",
        category: match.name,
        pattern: match.list
      }
    }

    var filter = {
      name: name,
      match: match,
      options: options,
      index: this.filterIndex++
    };

    this._filters.push(filter);
    this._populateFilter(filter);
    this._renderShadow();
  },

  removeFilter: function(name) {
    if (!this._filters || !this._filters) {
      return;
    }

    var filters = Polymer.dom(this.$.filters);

    if (!name) {
      /* Remove all filters */
      while (filters.firstChild) {
        filters.removeChild(filters.firstChild);
      }
      this._filters = [];
      this._renderShadow();
      return;
    }

    /* Look for the filter in the list of filters and remove from the
     * list of filters if found. */
    var filter = null;
    for (var i = 0; !filter && i < this._filters.length; i++) {
      if (this._filters[i].name != name) {
        continue;
      }

      filter = this._filters.splice(i, 1)[0];
    }

    if (!filter) {
      return;
    }

     /* If the name matches, delete all items in the #filter container
      * that were added for this filter */
    var matches = filters.querySelectorAll('[pattern="' + filter.index + '"]');
    Array.prototype.forEach.call(matches, function(el) {
      filters.removeChild(el);
    });

    this._renderShadow();
  },

  _onFilterUp: function(event) {
    if (this.tapTarget) {
      this.fire('item-tap', { refdes: this.tapTarget, event: event });
    }
    event.preventDefault();
  },

  _onFilterDown: function(event) {
    this.tapTarget = event.currentTarget.getAttribute('refdes');
    event.preventDefault();
  },

  /* Create all of the DIV elements that match the declared filter */
  _populateFilter: function(filter) {
    /* Delete all elements in the filter */
    var filters = Polymer.dom(this.$.filters),
      matches = filters.querySelectorAll('[pattern="' + filter.index + '"]');
    Array.prototype.forEach.call(matches, function(el) {
      filters.removeChild(el);
    }, this);

    if (!this._svg) {
      return;
    }

    var potentials = [];

    /* Walk the list of items in the SVG that match the BV_ prefix
     * and compare them to the filter pattern; if it is a match,
     * create a <DIV> in the filter layer */
    this._svgElements.forEach(function(svgItem) {
      /* Lookup the refdes in the _boardData */
      var item = this.findComponent(svgItem.refdes),
        match = false,
        isPin = item && item.type == "pin";

      /* If the match type is not ALL then only match items of the
       * appropriate type.
       *
       * An item that doesn't exist in the board.json is excluded from
       * type specific filters.
       */
      if ((filter.match.type != "ALL") &&
        (!item ||
         (filter.match.type == "PIN" && !isPin) ||
         (filter.match.type == "COMPONENT" && isPin))) {
        return;
      }

      switch (filter.match.type) {
      case "ALL":
      case "PIN":
      case "COMPONENT":
        /* If the pattern is *, then this is a match */
        match |= filter.match.pattern == '*';

        /* Check the REFDES against the pattern */
        match |= svgItem.refdes == filter.match.pattern;

        /* Check the KEYWORDS agsint the pattern */
        if (item && item.keywords) {
          for (var i = 0; !match && i < item.keywords.length; i++) {
            match |= item.keywords[i] == filter.match.pattern;
          }
        }
        break;

      case "LIST":
      case "CATEGORY":
        /* With LIST, filter.set is an array of REFDES or KEYWORDs to
         * match against */
        for (var i = 0; i < filter.match.pattern.length; i++) {
          /* Check the REFDES against the set entry */
          match |= svgItem.refdes == filter.match.pattern[i];

          /* Check the KEYWORDS agsint the set entry */
          if (item && item.keywords) {
            for (var j = 0; !match && j < item.keywords.length; j++) {
              match |= item.keywords[j] == filter.match.pattern[i];
            }
          }
          if (match) {
            break;
          }
        }
        break;
      }

      if (!match) {
        return;
      }

      potentials.push({ svgItem: svgItem, item: item});
    }, this);

    potentials.forEach(function(potential) {
      var item = potential.item,
          svgItem = potential.svgItem,
          isPin = item.type == "pin";
      /* If this is a COMPONENT, check if any of it's pins are
       * potential matches; if so, don't include the COMPONENT */
      if (!isPin) {
        if (item.pins) {
          for (var i = 0; i < item.pins.length; i++) {
            for (var j = 0; j < potentials.length; j++) {
              if (potentials[j].item == item.pins[i]) {
                /* Skip this COMPONENT; one of its PINs is in the list */
                return;
              }
            }
          }
        }
      }

      /* Create a DIV for this item */
      var div = document.createElement('div');
      div.setAttribute('refdes', item.refdes);

      /* Add related list of items to an aattibute within the div */
      if (item.related) {
        div.setAttribute('related', item.related.join());
      }

      /* Add connected list of items to an aattibute within the div */
      if (item.connected) {
        div.setAttribute('connected', item.connected.join());
      }

      div.setAttribute("pattern", filter.index);

      /* If this is a pin, set the 'pin' attribute so the z-index
       * goes above components */
      if (isPin) {
        div.setAttribute("pin", true);
      }

      /* The hover class sets opacity to 100% when :hover is
       * active on the element and it is set as `interactive`
       * otherwise set to 'bright' for full opacity */
      if (filter.options.interactive) {
        div.classList.add('interactive');
      }

      /* If alwaysVisible is set, the opacity is set to 50%
      * when the item is not active */
      if (filter.options.alwaysVisible) {
        div.classList.add('alwaysVisible');
      }

      var rect = svgItem.rect;

      div.style.color = filter.options.color;
      div.style.top = rect.top;
      div.style.left = rect.left;
      div.style.width = rect.width;
      div.style.height = rect.height;
      div.addEventListener('mouseover', this._onFilterOver.bind(this));
      div.addEventListener('mouseout', this._onFilterOut.bind(this));
      div.addEventListener('mousedown', this._onFilterDown.bind(this));
      div.addEventListener('mouseup', this._onFilterUp.bind(this));
      div.addEventListener('tap', this._onFilterTap.bind(this));

      Polymer.dom(this.$.filters).appendChild(div);
    }, this);

    Polymer.dom.flush();
    this.updateStyles();
  },

  /** Toggles an item in or out of the selected group. If control is not
   * pressed, the group is set to just the tapped item. */
  _onFilterTap: function(event) {
    /* Look up the item in the boardData */
    var item = this.findComponent(event.currentTarget.getAttribute('refdes'));
    if (!item) {
      console.log("Tap received for non filter item");
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    /* Look the item up in the selected list */
    var index = this.selected.indexOf(item.refdes);

    /* If Control is pressed, toggle the state of this item in the
     * selected group */
    if (event.detail.sourceEvent.ctrlKey) {
      this.multiSelectActive = true;
      if (index == -1) {
        this.push("selected", item.refdes);
      } else {
        this.splice("selected", index, 1);
      }
    } else {
      this.multiSelectActive = false;
      if (index == -1) {
        /* Set selected to just this item */
        this.selected = [ item.refdes ];
      } else {
        /* Set selected to none */
        this.selected = [];
      }
    }

    this._onSelectedChanged(this.selected);
  },

  getFilteredItems: function(filterName) {
    var filter = null, fiteredItems = [];
    for (var i = 0; !filter && i < this._filters.length; i++) {
      if (this._filters[i].name != filterName) {
        continue;
      }
      filter = this._filters[i];
    }
    if (filter == null) {
      return new Error('Filter with name: "' + filterName + '" was not found.')
    }
    var filters = Polymer.dom(this.$.filters),
    matches = filters.querySelectorAll('[pattern="' + filter.index + '"]');
    matches.forEach(function(item) {
      fiteredItems.push(item.getAttribute('refdes'));
    });
    return fiteredItems;
  },

  findFilterForItem: function(item) {
    var filterIndex = event.currentTarget.getAttribute("pattern");
    if (!filterIndex) {
      return null;
    }

    for (var i = 0; i < this._filters.length; i++) {
      if (this._filters[i].index == filterIndex) {
        return this._filters[i].name;
      }
    }
    return null;
  },

  _onFilterOver: function(event) {
    // Highlighting related and connected items bound to the hovered item.
    var connected, related;

    /* If no items are actively selected, then show associations to the hovered
     * pin, otherwise just fire that the pin was hovered over */
    if (connected = event.currentTarget.getAttribute('connected')) {
      this.addFilter('connected', connected.split(','), {
        color: "#ff8000",
        alwaysVisible: true,
        interactive: false
      });
    }
    if (related = event.currentTarget.getAttribute('related')) {
      this.addFilter('related', related.split(','), {
        color: "#00ff00",
        alwaysVisible: true,
        interactive: false
      });
    }

    // Fire the hover action.
    this.fire('item-hover', {
      in: true,
      refdes: event.currentTarget.getAttribute('refdes')
    });
  },

  _onFilterOut: function(event) {
    // Removing items related to the hovered item.
    this.removeFilter('connected');
    this.removeFilter('related');
    // Fire the unhover action.
    this.fire('item-hover', {
      in: false,
      refdes: event.currentTarget.getAttribute('refdes')
    });
  },

  resize: function() {
    this.debounce("resize", function() {
      if (!this._svg) {
        return;
      }

      Polymer.dom.flush();
      this.updateStyles();

      if (this._firstResize || !this.disableAutoResize) {
        var bb = this._svg.getBBox();

        /* Compare aspect ratio of the board with the aspect ratio of the
         * viewport and set the scale based on the best-fit */
        if (bb.width / bb.height > this.offsetWidth / this.offsetHeight) {
          /* Board is wider-angle than the viewport, so use width as best-fit */
          this.scale = this.defaultScale * this.offsetWidth / bb.width;
        } else {
          /* Board is narrower-angle than the viewport, so use height as best-fit */
          this.scale = this.defaultScale * this.offsetHeight / bb.height;
        }

        this._translate.x = this.offsetWidth * 0.5;
        this._translate.y = this.offsetHeight * 0.5;

        this._firstResize = false;
      }

      /* Translate before zoom; zoom will recaluclate the filter div dimensions
       * from the transformed SVG, including the _translate */
      this._onBoardMove(this._translate.x, this._translate.y);
      this._onBoardZoom(this._svg, this.zoom);

    }, 100);
  },

  _mapSvgToBoardData: function(svg, _boardData) {
    if (!_boardData || !svg || svg.tagName.toLowerCase() != 'svg') {
      console.log('SVG or _boardData not set. Not mapping.')
      return;
    }

    console.log('Mapping SVG to _boardData.');

    /* Delete any 'title' elements to keep hover tooltips from showing up */
    Array.prototype.forEach.call(svg.querySelectorAll('title'), function(el) {
      el.parentNode.removeChild(el);
    });

    var missing = [];
    /* Scan _boardData for all of the items named in the SVG --
     * reporting to console for any missing elements. */
    this._svgElements.forEach(function(svgItem) {
      var parts = svgItem.refdes.split("Pin"),
        isPin = parts.length == 2,
        component = this.findComponent(parts[0]),
        pin = isPin ? this.findComponent(svgItem.refdes) : false;

      if (!component) {
        /* Add the component to the _boardData */
        console.log('Component ' + parts[0] + ' not found in '
          + this._board + '/board.json');
        component = {
          type: "component",
          refdes: parts[0],
          name: parts[0],
          description: 'No description provided.'
        };

        this._boardData.push(component);
        missing.push(component);
      }

      if (isPin && !pin) {
        console.log('Pin ' + parts[1] + ' not found under ' + parts[0]
            + ' for ' + this._board + '/board.json');
        pin = {
          type: "pin",
          refdes: svgItem.refdes,
          name: svgItem.refdes,
          component: component.refdes,
          description: 'No description provided.'
        };

        if (!component.pins) {
          component.pins = [];
        }
        component.pins.push(pin);
      }
    }, this);

    /* Fire off a resize */
    this.resize();

    if (missing.length) {
      console.log("Missing items: " + JSON.stringify(missing, null, 2));
    }

    this._calculateSVGElements();
    this._filters.forEach(this._populateFilter, this);
    this._renderShadow();
  },

  _renderShadow: function() {
    this.debounce("render-shadow", function() {
      var filters = Polymer.dom(this.$.filters),
        holes = [],
        canvas = this.$.shadow,
        ctx = canvas.getContext("2d"),
        width = this.clientWidth,
        height = this.clientHeight;

      /* Render a hole anywhere there is a div in the filters */
      holes = this.$.filters.querySelectorAll("div");

      if (this.multiSelectActive || !this.selected || !this.selected.length || this.disableShadow) {
        this.$.shadow.classList.add("hidden");
        return;
      }

      canvas.setAttribute("width", width);
      canvas.setAttribute("height", height);

      this.$.shadow.classList.remove("hidden");

      var offset = this.getBoundingClientRect(),
        canvasRect = canvas.getBoundingClientRect(),
        svgRect = this.$.svg.getBoundingClientRect(),
        borderWidth = 0;

      ctx.save();
      /* Clear the shadow to dark gray */
      ctx.fillStyle = 'rgba(20,20,20,1)';
      ctx.fillRect(0, 0, canvasRect.width, canvasRect.height);

      /* Only draw where the target isn't 0; this will keep shadowsBlur
       * from drawing over cleared regions from other elements */
      ctx.globalCompositeOperation = "source-atop";

      /* Translate to the center of the board, and offset for user translation */
      ctx.translate(this._translate.x - canvasRect.width * 0.5,
        this._translate.y - canvasRect.height * 0.5);

      /* Enable the shadowBlur */
      ctx.shadowBlur = 10;
      ctx.shadowColor = "yellow";

      /* Set fill style to opaque to draw the shadow */
      ctx.fillStyle = "rgba(0, 0, 0, 1)";

      for (var i = 0; i < holes.length; i++) {
        var rect = {
          left: canvasRect.width * 0.5 + holes[i].offsetLeft - holes[i].offsetWidth * 0.5 - borderWidth,
          top: canvasRect.height * 0.5 + holes[i].offsetTop - holes[i].offsetHeight * 0.5 - borderWidth,
          width: holes[i].offsetWidth + borderWidth * 2,
          height: holes[i].offsetHeight + borderWidth * 2
        };

        /* Draw the shadow */
        ctx.fillRect(rect.left, rect.top, rect.width, rect.height);

        /* Clear the inside of the region */
        ctx.clearRect(rect.left, rect.top, rect.width, rect.height);
      }
      ctx.restore();
    });
  },

  getDocumentation: function(refdes, type, callback) {
    if (!this.board) {
      callback({
        error: "No board loaded.",
        status: 500
      });
    }

    /* Adjust for optional parameters */

    /* If type is not set, and refdes is set to HTML or MD,
     * set type to refdes and clear refdes. */
    if (!type) {
      if (refdes == "HTML" || refdes == "MD") {
        type = refdes;
        refdes = undefined;
      } else {
        type = "MD"; /* Default to Markdown */
      }
    }

    if (!callback) {
      return;
    }

    var url = this.basePath + "boards/" + this.board + "/";
    if (refdes) {
      var item = this.findComponent(refdes);
      if (item && item.markdown) {
        url += "docs/" + item.markdown;
      } else {
        url += "docs/" + refdes + ".md";
      }
    } else {
      url += "index.md";
    }

    var ironRequest = document.createElement('iron-request');
    ironRequest.send({url: url}).then(function(request) {
      var content;
      try {
        content = Mustache.render(request.response, item);

        if (type && type == 'HTML') {
          content = this.md.render(content);
        }
      } catch (_) {
        callback({
          error: "Unable to parse returned content.",
          status: 500
        });
        return;
      }

      callback({
        status: 200,
        content: content
      });
    }.bind(this)).catch(function(error) {
      callback({
        error: "Unable to load documentation for " + refdes,
        status: 400
      });
    });
  },

  getInfo: function(refdes) {
    var item = this.findComponent(refdes);
    if (item) {
      return item;
    }

    /* No item found in the _boardData -- see if it exists in the
     * _svgElements cache and return just a refdes if so, otherwise
     * return null */
    for (var i = 0; i < this._svgElements.length; i++) {
      if (this._svgElements[i].refdes == refdes) {
        return { refdes: refdes };
      }
    }

    return null;
  },

  getBoards: function(callback) {
    if (!callback) {
      return;
    }

    this.$.boards.send({
      url: this.basePath + "boards.json",
      handleAs: "json"
    }).then(function(request) {
      var boards = request.response,
        results = [];
      if (!boards || !Array.isArray(boards)) {
        return Promise.reject("boards.json did not return any boards.");
      }
      boards.forEach(function(board) {
        results.push({
          name: board.title,
          directory: board.board,
          image: board.board + '/' + board.image
        });
      })

      results = results.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });

      callback(results);
    }.bind(this)).catch(function(error) {
      console.log("Unable to load boards.json");
      callback(new Error(error));
    });
  },

  getKeywords: function(callback) {
    if (!callback) {
      return;
    }

    var keywords = [];

    function buildKeywords(item) {
      if ("keywords" in item) {
        item.keywords.forEach(function(keyword) {
          if (keywords.indexOf(keyword) == -1) {
            keywords.push(keyword);
          }
        });
      }

      return keywords;
    }

    this._boardData.forEach(function(component) {
      if (component.pins) {
        component.pins.forEach(buildKeywords);
      }
      buildKeywords(component);
    });

    callback(keywords.sort());
  },

  getComponents: function(callback) {
    var components = [];
    if (!callback) {
      return;
    }

    this._boardData.forEach(function(component) {
      components.push(component.refdes);
    });

    /* Sort the components, supporting numerical sorting in names */
    components = components.sort(function(a, b) {
      var partsA = a.match(/([^0-9]*)([0-9]*)(.*)/),
        partsB = b.match(/([^0-9]*)([0-9]*)(.*)/),
        results = partsA[1].localeCompare(partsB[1]);
      if (results != 0) {
        return results;
      }
      results = partsA[2] - partsB[2];
      if (results != 0) {
        return results;
      }
      return partsA[3].localeCompare(partsB[3]);
    });

    callback(components);
  },

  attached: function() {
    this.md = window.markdownit({
      html: false,
      xhtmlout: false,
      breaks: false
    });

    if (this.hasAttribute("board")) {
      this.loadBoard(this.getAttribute("board"));
    }
  }
});
</script>
