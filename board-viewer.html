<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../paper-slider/paper-slider.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../iron-ajax/iron-request.html">

<script src="../es6-shim/es6-shim.min.js"></script>
<script src="../markdown-it/dist/markdown-it.js"></script>

<script src="svg-injector.js"></script>

<!--
`<board-viewer>` Provides an interactive hardware board viewer.

Example:

    <board-viewer
      enable-drag
      enable-zoom
      filters="I2C,JTAG,J6"
      board="quark_mcu_dev_kit_d2000">
    </board-viewer>

The above will load the `quark_mcu_dev_kit_d2000` out of the `boards/`,
and start by highlighting the graphic components with keywords or ids matching
`I2C`, `JTAG`, or `J6`.

See [board-explorer](https://github.com/board-explorer/board-explorer) for
information on creating board files.

@demo demo/index.html Simple demo showing a statically loaded view.
-->

<dom-module id='board-viewer'>
  <template>
  <style>
    /* The board-viewer only uses div and img; reset those elements
     * to their initial settings within the .board-viewer namespace */
    :host {
      display: block;
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      background-color: #23ccfc;
      z-index: 0;
      overflow: hidden !important;
    }

    :host div {
      overflow: visible;
      box-sizing: content-box;
    }

    #viewer {
      cursor: default;
    }

    :host[enable-drag] #viewer {
      cursor: move;
      cursor: -webkit-grab;
      cursor: -moz-grab;
      cursor: grab;
    }

    .drag {
      cursor: move !important;
      cursor: -webkit-grabbing !important;
      cursor: -moz-grabbing !important;
      cursor: grabbing !important;
    }

    #svg,
    #filters {
      display: inline-block;
      position: absolute;
      top: 0px;
      left: 0px;
      -ms-transform-_origin: 50% 50%; /* IE 9 */
      -webkit-transform-_origin: 50% 50%; /* Chrome, Safari, Opera */
      transform-_origin: 50% 50%;
    }

    #svg {
      pointer-events: none;
    }

    #filters {
      z-index: 100;
    }

    #filters > div {
      position: absolute;
      opacity: 1;
      border-width: 2px;
      border-style: solid;
      padding: 0.1em;
      box-sizing: content-box;
      transition: opacity 0.25s linear;
      border-radius: 0.25rem;
      transform: translate(-50%, -50%);
      cursor: pointer;
      pointer-events: none;
    }

    #filters > div[pin] {
      z-index: 200;
    }

    /* Interactive, if not alwaysVisible, are transparent when not hovered */
    #filters > div.interactive {
      pointer-events: all;
      opacity: 0;
    }

    /* Hovering over interactive elements makes them full bright */
    #filters > div.interactive:hover,
    #filters > div.interactive.alwaysVisible:hover {
      opacity: 1;
    }

    /* alwaysVisible are half dim when not highlighted */
    #filters > div.alwaysVisible,
    #filters > div.interactive.alwaysVisible {
      opacity: 0.5;
    }

    /* Non-interactive and alwaysVisible are always bright */
    #filters > div.alwaysVisible:not(.interactive) {
      opacity: 1;
    }

    #board {
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      padding: 0;
      margin: 0;
      width: 100%;
      height: 100%;
      position: absolute;
      z-index: 0;
      pointer-events: none;
    }

    #viewer {
      position: relative;
      box-sizing: border-box;
      height: 100%;
      width: 100%;
    }

    #container {
      position: absolute;
      display: inline-block;
      box-sizing: border-box;
      top: 0px;
      left: 0px;
      height: 100%;
      width: 100%;
    }
  </style>

  <div id="viewer">
    <iron-request id="boards"></iron-request>
    <iron-ajax auto handle-as="json" id="board"></iron-ajax>

    <div id="container">
      <div id="svg"><!-- holds the created IMG that SVGInjector() uses--></div>
      <div id="filters"></div>
    </div>

    <template is="dom-if" if="{{enableZoom}}"><paper-slider id="zoomControl" step="0.1" min="0" max="2" value="0" on-immediate-value-changed="_onZoomChanged"></paper-slider></template>
  </div>
</template>

<script>
"use strict";

Polymer({
  is: "board-viewer",
  properties: {
    /** Whether the zoom operations are available / control is visible. */
    enableZoom: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },
    /** Whether dragging the board is enabled. */
    enableDrag: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },
    /** The board name currently loaded (or loading). This will be loaded
     * out of the *basePath* directory as *basePath/board* */
    board: {
      type: String,
      readOnly: true,
      notify: true
    },
    /** The zoom level of the board. Minimum: 0.5, Maximum: 1.5 */
    zoom: {
      type: Number,
      value: 0,
      notify: true
    },
    /** Default scale for the board. 1.0 fills the viewport (while maintaining
     * aspect ratio.) */
    defaultScale: {
      type: Number,
      value: 0.8
    },
    /** Base path for loading meta-data files */
    basePath: {
      type: String,
      value: ""
    },
    /** Comma separated list of refdes, keywords, and groups to show.
     * For example: "JTAG,I2C,J6" */
    filters: {
      type: String
    },
    _translation: {
      type: Object,
      value: {
        x: 0,
        y: 0
      }
    },
    _filters: { /* Internal copy of filters */
      type: Array,
      value: []
    },
    _origin: { /* Used for drag operations */
      type: Object,
      value: { x: 0, y: 0 }
    },
    _boardData: {
      type: Array,
      value: []
    },
    _boardElements: {
      type: Array,
      value: []
    },
    _categories: {
      type: Array,
      value: []
    },
    _svg: {
      type: Object
    },
    scaling: {
      type: Boolean,
      value: false
    },
    trackPoints: {
      type: Array,
      value: []
    }
  },

  observers: [
    "_onEnableDrag(enableDrag)",
    "_onEnableZoom(enableZoom)",
    "_onBoardZoom(_svg, zoom)",
    "_mapSvgToBoardData(_svg, _boardData)",
    "_onFiltersChanged(filters)"
  ],

  behaviors: [
    /* @polymerBehavior Polymer.IronResizableBehavior */
    Polymer.IronResizableBehavior
  ],

  listeners: {
    "iron-resize" : "resize",
    "touchmove": "_onPinch",
    "wheel": "_onScroll",
    "board.response": "_boardLoaded",
    "board.error": "_boardLoadError"
  },

  _onScroll: function(event) {
    /* Getting zoom-bar. */
    var zoomControl = this.$$('#zoomControl');
     /* Inverted aim. */
    if (event.deltaY < 0) {
      this.zoom = Math.max(Math.min(this.zoom + 0.1, 2.0), 0);
    }
    else {
      this.zoom = Math.max(Math.min(this.zoom - 0.1, 2.0), 0);
    }
     /* Adjusting bar progres to current zoom value. */
    zoomControl.value = this.zoom;
  },

  _onPinch: function(event) {
    /* Detecting single or none touches: */
    if (event.changedTouches.length < 2) {
      // When scaling is on, then end.
      if (this.scaling) {
        this.trackPoints = [];
        this.scaling = false;
      }
      /* A single touch, returning track listener to defult state. */
      else {
        this.enableDrag ? this.listen(this, 'track', '_onTrack') : this.unlisten(this, 'track', '_onTrack');
      }
    }
    /* When a couple of touches are detected, start scaling. */
    else if (!this.scaling && event.changedTouches.length == 2) {
      /* forcing to disable track listener while scaling. */
      this.unlisten(this, 'track', '_onTrack');
      this.scaling = true;
    }
    /* Maths while scaling: */
    if (this.scaling) {
      /* Calculating distance between finger touches. */
      var dist = Math.sqrt(
        Math.pow(event.changedTouches[0].clientX - event.changedTouches[1].clientX, 2) +
        Math.pow(event.changedTouches[0].clientY - event.changedTouches[1].clientY, 2)
      );
      /* Storing distances to compare. */
      this.trackPoints.push(dist);
      /* We need to compare the last two distances stored to determine if,
      is a zoom in or zoom out. */
      if (this.trackPoints.length >= 2) {
        var finalDistance = this.trackPoints[this.trackPoints.length - 1];
        var initialDistance = this.trackPoints[this.trackPoints.length - 2];
        var zoomControl = this.$$('#zoomControl');
        /* Pinch is growing, then zoom in. */
        if (finalDistance > initialDistance) {
          this.zoom = Math.max(Math.min(this.zoom + 0.1, 2.0), 0);
        }
        /* Pinch is getting smaller, then zoom out. */
        else {
          this.zoom = Math.max(Math.min(this.zoom - 0.1, 2.0), 0);
        }
        zoomControl.value = this.zoom;
      }
    }
  },

  _onFiltersChanged: function(filters) {
    if (typeof filters === "string") {
      filters = filters.split(",");
    }
    if (!Array.isArray(filters)) {
      filters = [ filters ];
    }
    this.addFilter("selected", {
      type: "LIST", set: filters
    }, {
      color: "#ffff00",
      interactive: false,
      alwaysVisible: true
    });
  },

  /* This needs to be connected to the zoom slider control (currently not
   * implemented) */
  _onZoomChanged: function(event) {
    this.zoom = Math.max(Math.min(event.detail.value, 2.0), 0);
  },

  _onBoardMove: function(x, y) {
    /* Can get called during initialization before DOM stamped */
    var container = this.$.container;
    if (!container) {
      return;
    }
    container.style.top = y + 'px';
    container.style.left = x + 'px';

    Polymer.dom.flush();
  },

  _onBoardZoom: function(svg, zoom) {
    if (!svg) {
      return;
    }

    zoom = this.scale + this.scale * zoom;

    var transform = '', style = '', bb;

    /* Work around Firefox issue #612118; getBBox() throws an exception if
     * the SVG is not being rendered */
    try {
      bb = svg.getBBox();
    } catch (_) {
      return;
    }

    transform = "translate("
      + -bb.width * zoom * 0.5 + "px,"
      + -bb.height * zoom * 0.5 + "px)";
    style += '-webkit-transform:' + transform + ';';
    style += '-ms-transform:' + transform + ';';
    style += '-moz-transform:' + transform + ';';
    style += 'transform:' + transform + ';';
    style += 'width: ' + bb.width * zoom + 'px;';
    style += 'height: ' + bb.height * zoom + 'px;';

    this.$.svg.style.cssText = style;
    Polymer.dom.flush();

    /* Unhide the SVG itself; we hide it when the board is being loaded. We
    * don't show it until now because the style for the parent (this.$.svg)
    * would have it in the wrong spot */
    this._svg.style.width = "100%";
    this._svg.style.height = "100%";
    this._svg.style.visibility = 'visible';

    this._calculateSVGElements();
    this._filters.forEach(this._populateFilter, this);
  },

  _calculateSVGElements: function() {
    var offset = this.getBoundingClientRect();

    this._svgElements.forEach(function(svgItem) {
      var rect = svgItem.el.getBoundingClientRect();
      svgItem.rect = {
        top: rect.top + rect.height * 0.5 - this._translation.y - offset.top + 'px',
        left: rect.left + rect.width * 0.5 - this._translation.x - offset.left + 'px',
        width: rect.width + 'px',
        height: rect.height + 'px'
      }
    }, this);
  },

  _onEnableDrag: function(enabled) {
    if (!enabled) {
      this.unlisten(this, 'track', '_onTrack');
    } else {
      this.listen(this, 'track', '_onTrack');
    }
  },

  _onEnableZoom: function(enabled) {
    if (!enabled) {
      if (this.$$('#zoomControl')) {
        this.$$('#zoomControl').setAttribute('disabled', '');
      }
      this.unlisten(this, 'touchmove', '_onPinch');
      this.unlisten(this, 'wheel', '_onScroll');
    } else {
      if (this.$$('#zoomControl')) {
        this.$$('#zoomControl').removeAttribute('disabled');
      }

      this.listen(this, 'touchmove', '_onPinch');
      this.listen(this, 'wheel', '_onScroll');
    }
  },

  _onTrack: function(event) {
    this.tapTarget = null;
    event.preventDefault();

    if (event.detail.state == 'start') {
      event.target.classList.add('drag');
      this.$.viewer.classList.add('drag');
      this._origin = {
        x: this._translation.x,
        y: this._translation.y
      }
    }

    this._translation.x = this._origin.x + event.detail.dx;
    this._translation.y = this._origin.y + event.detail.dy;
    this._onBoardMove(this._translation.x, this._translation.y);

    if (event.detail.state == 'end') {
      Array.prototype.forEach.call(this.querySelectorAll('.drag'),
        function(el) {
        el.classList.remove('drag');
      });
      this._origin.x = this._translation.x;
      this._origin.y = this._translation.y;
    }
  },

  /* Look up the item corresponding to the provided
   * refdes
   *
   * @param {String} refdes Reference designator to look up, for example J6Pin4
   * @returns {Object}
   */
  findComponent: function(refdes) {
    if (!refdes) {
      return null;
    }

    var parts = refdes.split("Pin"),
      isPin = parts.length == 2,
      component = null;

    /* Look up the component first */
    for (var i = 0; i < this._boardData.length; i++) {
      if (this._boardData[i].refdes == parts[0]) {
        component = this._boardData[i];
        break;
      }
    }

    if (!component) {
      return null;
    }

    /* If the inbound refdes isn't a pin, return the component */
    if (!isPin) {
      return component;
    }

    /* If no pins are on this component, we can't find the requested pin,
     * so return null */
    if (!component.pins) {
      return null;
    }

    /* Look for the pin in this component */
    for (var i = 0; i < component.pins.length; i++) {
      if (component.pins[i].refdes == refdes) {
        return component.pins[i];
      }
    }

    /* No matches anywhere... return null */
    return null;
  },

  /** Load a new board.
   *
   * @param {String} board The name of the board to load.
   */
  loadBoard: function(board) {
    this._board = board;

    this._svg = null;
    this._boardData = [];
    this._categories = [];

    /* Remove all the filters for the current board */
    this.removeFilter();

    /* Delete any children of the "svg" */
    var element = this.$.svg;
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }

    this._setBoard("");

    if (!board || board == '') {
      return;
    }

    console.log('Loading ' + board + ' into board-viewer.');
    var url = this.basePath + "boards/" + this._board + "/board.json";
    if (this.$.board.url == url) {
      this.$.board.generateRequest();
    } else {
      this.$.board.url = url;
    }
  },

  _boardLoaded: function(event) {
    console.log("Parsing " + this._board);

    var image = document.createElement('img');

    image.style.visibility = 'hidden';

    /* SVGInjector replaces 'image' with the svg it constructs
     *
     * Add the image to the document body; if we add it to the board-viewer,
     * and the board-viewer is currently 'display: none', the SVG does not
     * get setup correctly. */
    document.body.appendChild(image);

    /* Do not inject the SVG until after the SVG has completed
     * loading into the main image, otherwise there is a race
     * c_onDition which can result in the SVG never showing up */
    image.onload = function() {
      SVGInjector(image, {
        evalScripts: 'once',
        each: function(svg) {
          if (typeof svg == 'string') {
            console.log('ERROR: ' + svg);
            return;
          }

          Polymer.dom.flush();

          svg.setAttribute('board', this._board);
          /* Trim off any whitespace/viewbox padding from the SVG
           * asset */
          var bb = svg.getBBox();
          svg.setAttribute('viewBox', bb.x + ' ' + bb.y + ' ' + bb.width + ' ' + bb.height);
          svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

          this.zoom = 0;
          this.scale = 1;
          this._translation.x = this.offsetWidth * 0.5;
          this._translation.y = this.offsetHeight * 0.5;

          /* Caches the _original (unscaled or translated) bounding rectangle
          * for use when constructing new highlight rectangles */
          this._svgElements = [];

          Array.prototype.forEach.call(svg.querySelectorAll('[id^="BV_"]'),
            function(el) {
            this._svgElements.push({
              refdes: el.id.replace(/^BV_/, ''),
              el: el
            });
          }, this);

          this.$.svg.appendChild(svg);
          Polymer.dom.flush();
          this.updateStyles();

          /* Set this._svg at the end so _mapSvgToBoardData doesn't trigger
           * until the DOM is populated with the SVG */
          this._svg = svg;
        }.bind(this)
      });
    }.bind(this);

    var data = this.$.board.lastResponse;

    /* For now we only support one side of the board -- front. */
    image.src = "boards/" + this._board + "/" + data.views.front.image;

    var categoryList = data.categories;
    data = data.views.front.components;
    var components = [];

    for (var key in data) {
      if (typeof data[key] != 'object') {
        console.log("Skipping non object '" + key + ".'");
        continue;
      }

      /* Create "smart" defaults based on normal structures */
      var component = Object.assign({
        refdes: key,
        readable: key,
        name: key
      }, data[key]);

      /* Do not let the JSON override the type */
      component.type = "component";

      if (component.keywords) {
        for (var i = 0; i < component.keywords.length; i++) {
          component.keywords[i] = component.keywords[i].toUpperCase();
        }
      }

      components.push(component);

      if ("pins" in data[key]) {
        component.pins = [];
        for (var id in data[key].pins) {
          var isJumper = component.keywords && (component.keywords.indexOf("JUMPER") != -1),
            readable;

          if (isJumper) {
            readable = component.refdes + " Pins " + id.substr(0, 1) + "-" + id.substr(1, 1);
          } else {
            readable = component.refdes + " Pin " + id;
          }

          /* Create "smart" defaults based on normal structures */
          var item = Object.assign({
            refdes: component.refdes + "Pin" + id,
            readable: readable,
            name: readable,
            component: component.refdes
          }, data[key].pins[id]);

          /* Do not let the JSON override the type */
          item.type = "pin";

          if (item.keywords) {
            for (var i = 0; i < item.keywords.length; i++) {
              item.keywords[i] = item.keywords[i].toUpperCase();

              /* Ensure that the parent component is the superset of all
               * keywords of all contained pins */
              if (!component.keywords) {
                component.keywords = [];
              }
              if (component.keywords.indexOf(item.keywords[i]) == -1) {
                component.keywords.push(item.keywords[i]);
              }
            }

            item.keywords = item.keywords.sort();
          }

          if (component.keywords) {
            component.keywords = component.keywords.sort();
          }

          component.pins.push(item);
        }
      }
    }

    /* Set _boardData first since findComponent is used when configuring
     * categories. */
    this._boardData = components;
    /* Rewalking components to find implicit relationships */
    for (var i = 0; i < this._boardData.length; i ++) {
      this._boardData[i].implicitRelated = this.getImplicitRelations(this._boardData[i].refdes, 'related');
      this._boardData[i].implicitConnected = this.getImplicitRelations(this._boardData[i].refdes, 'connected');
      if (this._boardData[i].pins) {
        for (var j = 0; j < this._boardData[i].pins.length; j ++) {
          this._boardData[i].pins[j].implicitRelated = this.getImplicitRelations(this._boardData[i].pins[j].refdes, 'related');
          this._boardData[i].pins[j].implicitConnected = this.getImplicitRelations(this._boardData[i].pins[j].refdes, 'connected');
        }
      }
    }

    var categories = [];
    if (categoryList) {
      if (!Array.isArray(categoryList)) {
        console.warn("'categories' should be an array of { name: string, list: []}");
      } else {
        categoryList.forEach(function(category, index) {
          var entry = {
            list: []
          };
          if (!category.name || typeof category.name !== 'string') {
            console.warn("'name' is missing or not a string in category #" + index);
            return;
          }
          if (!category.list || !Array.isArray(category.list)) {
            console.warn("'list' is missing or not an array in category #" + index);
            return;
          }

          entry.name = category.name;

          category.list.forEach(function(refdes) {
            var item = this.findComponent(refdes);
            if (!item) {
              console.warn("'" + refdes + "' listed in category #" + index + " does not exist.");
              return;
            }
            entry.list.push(refdes);
          }.bind(this));

          categories.push(entry);
        }.bind(this));
      }
    }

    this._categories = categories;
    this._setBoard(this._board);
  },

  _boardLoadError: function(event) {
    console.log("Unable to load boards/" + this._board + ".json");
  },

  hasFilter: function(name) {
    for (var i = 0; i < this._filters.length; i++) {
      if (this._filters[i].name == name) {
        return true;
      }
    }

    return false;
  },

  getImplicitRelations: function (refdes, type) {
    var relatedRefdes = [];
    /* Walk backward and find if refdes is within a connected/related set,
    in other component. */
    relatedRefdes = relatedRefdes.concat(this._searchBackReferences(refdes, type));
    /* If we found a previus references we need to still rewalking behind,
    the references added. */
    var i = 0;
    do {
      /* Appending previous references */
      relatedRefdes = relatedRefdes.concat(this._searchBackReferences(relatedRefdes[i], type));
      i++;
    } while(i < relatedRefdes.length);
    /* Walking foward */
    var component = this.findComponent(refdes);
    var rels = (type == 'connected') ? component.connected : component.related;
    /* If we have an explicit set of related/connected */
    if (rels) {
      /* Appending inital set, to the previous references. */
      relatedRefdes = relatedRefdes.concat(rels);
      i = relatedRefdes.length - rels.length - 1;
      do {
         /* Appending explicit references of foward elements */
        relatedRefdes = relatedRefdes.concat(this._searchAheadReferences(relatedRefdes[i], type));
        i++;
      } while(i < relatedRefdes.length);
    }
    return relatedRefdes;
  },

  _searchBackReferences: function(refdes, type) {
    var components =  this._boardData, relatedRefdes = [];
    for (var i = 0; i < components.length; i++) {
      /* We get the set to start find the refdes within */
      var rels = (type == 'connected') ? components[i].connected : components[i].related;
      /* The component has the refdes in the set, then add the refdes into the array */
      if (rels && rels.indexOf(refdes) != -1) {
        relatedRefdes.push(components[i].refdes);
      }
      /* If the component have pins, do the same on them */
      if (components[i].pins) {
        var pins =  components[i].pins;
        for (var j = 0; j < pins.length; j++) {
          rels = (type == 'connected') ? pins[j].connected : rels = pins[j].related;;
          if (rels && rels.indexOf(refdes) != -1) {
            relatedRefdes.push(pins[j].refdes);
          }
        }
      }
    }
    return relatedRefdes;
  },

  _searchAheadReferences: function(refdes, type) {
    var component = this.findComponent(refdes), relatedRefdes = [];
    /* Only if we found a connected set */
    if (component) {
      var rels = (type == 'connected') ? component.connected : component.related;
      if (rels) {
        relatedRefdes = relatedRefdes.concat(rels);
      }
      /* If the component have pins, do the same */
      if (component.pins) {
        var pins =  component.pins;
        for (var j = 0; j < component.pins.length; j++) {
          rels = (type == 'connected') ? pins.connected : pins.related;
          if (rels) {
            relatedRefdes = relatedRefdes.concat(rels);
          }
        }
      }
    }
    return relatedRefdes;
  },

  /** Get the list of component categories.
   */
  getCategories: function() {
    return this._categories;
  },

  /** Add a filter.
   *
   * @param {String} name The name of the filter.
   * @param {Object} match Parameters for the filter match criteria.
   * @param {Object} options Style and interaction attributes for this filter.
   */
  addFilter: function(name, match, options) {
    for (var i = 0; i < this._filters.length; i++) {
      if (this._filters[i].name == name) {
        this.removeFilter(name);
        break;
      }
    }

    /* Assign default values to the options */
    options = Object.assign({
      color: "#00ff00",
      alwaysVisible: false,
      interactive: true
    }, options || {});

    if (!this.filterIndex) {
      this.filterIndex = 1;
    }

    if (typeof match === "string") {
      match = {
        type: "ALL",
        pattern: match
      }
    }

    var filter = {
      name: name,
      match: match,
      options: options,
      index: this.filterIndex++
    };

    this._filters.push(filter);
    this._populateFilter(filter);
  },

  removeFilter: function(name) {
    var filters = Polymer.dom(this.$.filters);

    if (!name) {
      /* Remove all filters */
      while (filters.firstChild) {
        filters.removeChild(filters.firstChild);
      }
      this._filters = [];
      return;
    }

    /* Look for the filter in the list of filters and remove from the
     * list of filters if found. */
    var filter = null;
    for (var i = 0; !filter && i < this._filters.length; i++) {
      if (this._filters[i].name != name) {
        continue;
      }

      filter = this._filters.splice(i, 1)[0];
    }

    if (!filter) {
      return;
    }

     /* If the name matches, delete all items in the #filter container
      * that were added for this filter */
    var matches = filters.querySelectorAll('[pattern="' + filter.index + '"]');
    Array.prototype.forEach.call(matches, function(el) {
      filters.removeChild(el);
    });
  },

  _onFilterUp: function(event) {
    if (this.tapTarget) {
      this.fire('item-tap', { refdes: this.tapTarget, event: event });
    }
    event.preventDefault();
  },

  _onFilterDown: function(event) {
    this.tapTarget = event.currentTarget.getAttribute('refdes');
    event.preventDefault();
  },

  /* Create all of the DIV elements that match the declared filter */
  _populateFilter: function(filter) {
    /* Delete all elements in the filter */
    var filters = Polymer.dom(this.$.filters),
      matches = filters.querySelectorAll('[pattern="' + filter.index + '"]');
    Array.prototype.forEach.call(matches, function(el) {
      filters.removeChild(el);
    }, this);

    if (!this._svg) {
      return;
    }

    var potentials = [];

    /* Walk the list of items in the SVG that match the BV_ prefix
     * and compare them to the filter pattern; if it is a match,
     * create a <DIV> in the filter layer */
    this._svgElements.forEach(function(svgItem) {
      /* Lookup the refdes in the _boardData */
      var item = this.findComponent(svgItem.refdes),
        match = false,
        isPin = item && item.type == "pin";

      /* If the match type is not ALL then only match items of the
       * appropriate type.
       *
       * An item that doesn't exist in the board.json is excluded from
       * type specific filters.
       */
      if ((filter.match.type != "ALL") &&
        (!item ||
         (filter.match.type == "PIN" && !isPin) ||
         (filter.match.type == "COMPONENT" && isPin))) {
        return;
      }

      switch (filter.match.type) {
      case "ALL":
      case "PIN":
      case "COMPONENT":
        /* If the pattern is *, then this is a match */
        match |= filter.match.pattern == '*';

        /* Check the REFDES against the pattern */
        match |= svgItem.refdes == filter.match.pattern;

        /* Check the KEYWORDS agsint the pattern */
        if (item && item.keywords) {
          for (var i = 0; !match && i < item.keywords.length; i++) {
            match |= item.keywords[i] == filter.match.pattern;
          }
        }
        break;

      case "LIST":
        /* With LIST, filter.set is an array of REFDES or KEYWORDs to
         * match against */

        for (var i = 0; i < filter.match.set.length; i++) {
          /* Check the REFDES against the set entry */
          match |= svgItem.refdes == filter.match.set[i];

          /* Check the KEYWORDS agsint the set entry */
          if (item && item.keywords) {
            for (var j = 0; !match && j < item.keywords.length; j++) {
              match |= item.keywords[j] == filter.match.set[i];
            }
          }
          if (match) {
            break;
          }
        }
        break;
      }

      if (!match) {
        return;
      }

      potentials.push({ svgItem: svgItem, item: item});
    }, this);

    potentials.forEach(function(potential) {
      var item = potential.item,
          svgItem = potential.svgItem,
          isPin = item.type == "pin";
      /* If this is a COMPONENT, check if any of it's pins are
       * potential matches; if so, don't include the COMPONENT */
      if (!isPin) {
        if (item.pins) {
          for (var i = 0; i < item.pins.length; i++) {
            for (var j = 0; j < potentials.length; j++) {
              if (potentials[j].item == item.pins[i]) {
                /* Skip this COMPONENT; one of its PINs is in the list */
                return;
              }
            }
          }
        }
      }

      /* Create a DIV for this item */
      var div = document.createElement('div');
      div.setAttribute('refdes', item.refdes);

      /* Add related list of items to an aattibute within the div */
      if (item.implicitRelated) {
        div.setAttribute('related', item.implicitRelated.join());
      }
      /* Add connected list of items to an aattibute within the div */
      if (item.implicitConnected) {
        div.setAttribute('connected', item.implicitConnected.join());
      }

      /* The over class sets opacity to 100% when :hover is
       * active on the element and it is set as `interactive`
       * otherwise set to 'bright' for full opacity */
      if (filter.options.interactive) {
        div.classList.add('interactive');
      }

      div.setAttribute("pattern", filter.index);

      /* If this is a pin, set the 'pin' attribute so the z-index
       * goes above components */
      if (isPin) {
        div.setAttribute("pin", true);
      }

      /* If alwaysVisible is set, the opacity is set to 50%
      * when the item is not active */
      if (filter.options.alwaysVisible) {
        div.classList.add('alwaysVisible');
      }

      var rect = svgItem.rect;

      div.style.color = filter.options.color;
      div.style.top = rect.top;
      div.style.left = rect.left;
      div.style.width = rect.width;
      div.style.height = rect.height;
      div.addEventListener('mouseover', this._onFilterOver.bind(this));
      div.addEventListener('mouseout', this._onFilterOut.bind(this));
      div.addEventListener('mousedown', this._onFilterDown.bind(this));
      div.addEventListener('mouseup', this._onFilterUp.bind(this));

      Polymer.dom(this.$.filters).appendChild(div);
    }, this);

    Polymer.dom.flush();
    this.updateStyles();
  },

  getFilteredItems: function(filterName) {
    var filter = null, fiteredItems = [];
    for (var i = 0; !filter && i < this._filters.length; i++) {
      if (this._filters[i].name != filterName) {
        continue;
      }
      filter = this._filters[i];
    }
    if (filter == null) {
      return new Error('Filter with name: "' + filterName + '" was not found.')
    }
    var filters = Polymer.dom(this.$.filters),
    matches = filters.querySelectorAll('[pattern="' + filter.index + '"]');
    matches.forEach(function(item) {
      fiteredItems.push(item.getAttribute('refdes'));
    });
    return fiteredItems;
  },

  findFilterForItem: function(item) {
    var filterIndex = event.currentTarget.getAttribute("pattern");
    if (!filterIndex) {
      return null;
    }

    for (var i = 0; i < this._filters.length; i++) {
      if (this._filters[i].index == filterIndex) {
        return this._filters[i].name;
      }
    }
    return null;
  },

  _onFilterOver: function(event) {
    // Highlighting related and connected items bound to the hovered item.
    var connected, related;
    if (connected = event.currentTarget.getAttribute('connected')) {
      this.addFilter('connected', {type: 'LIST', set: connected.split(',')}, {
        color: "#ff8000",
        alwaysVisible: true,
        interactive: false
      });
    }
    if (related = event.currentTarget.getAttribute('related')) {
      this.addFilter('related', {type: 'LIST', set: related.split(',')}, {
        color: "#00ff00",
        alwaysVisible: true,
        interactive: false
      });
    }
    // Fire the hover action.
    this.fire('item-hover', {
      in: true,
      refdes: event.currentTarget.getAttribute('refdes')
    });
  },

  _onFilterOut: function(event) {
    // Removing items related to the hovered item.
    this.removeFilter('connected');
    this.removeFilter('related');
    // Fire the unhover action.
    this.fire('item-hover', {
      in: false,
      refdes: event.currentTarget.getAttribute('refdes')
    });
  },

  resize: function() {
    this.debounce("resize", function() {
      if (!this._svg) {
        return;
      }
      var bb = this._svg.getBBox();

      Polymer.dom.flush();
      this.updateStyles();
      /* Compare aspect ratio of the board with the aspect ratio of the
       * viewport and set the scale based on the best-fit */
      if (bb.width / bb.height > this.offsetWidth / this.offsetHeight) {
        /* Board is wider-angle than the viewport, so use width as best-fit */
        this.scale = this.defaultScale * this.offsetWidth / bb.width;
      } else {
        /* Board is narrower-angle than the viewport, so use height as best-fit */
        this.scale = this.defaultScale * this.offsetHeight / bb.height;
      }

      this._translation.x = this.offsetWidth * 0.5;
      this._translation.y = this.offsetHeight * 0.5;
      /* Translate before zoom; zoom will recaluclate the filter div dimensions
       * from the transformed SVG, including the _translation */
      this._onBoardMove(this._translation.x, this._translation.y);
      this._onBoardZoom(this._svg, this.zoom);
    }, 100);
  },

  _mapSvgToBoardData: function(svg, _boardData) {
    if (!_boardData || !svg || svg.tagName.toLowerCase() != 'svg') {
      console.log('SVG or _boardData not set. Not mapping.')
      return;
    }

    console.log('Mapping SVG to _boardData.');

    /* Delete any 'title' elements to keep hover tooltips from showing up */
    Array.prototype.forEach.call(svg.querySelectorAll('title'), function(el) {
      el.parentNode.removeChild(el);
    });

    var missing = [];
    /* Scan _boardData for all of the items named in the SVG --
     * reporting to console for any missing elements. */
    this._svgElements.forEach(function(svgItem) {
      var parts = svgItem.refdes.split("Pin"),
        isPin = parts.length == 2,
        component = this.findComponent(parts[0]),
        pin = isPin ? this.findComponent(svgItem.refdes) : false;

      if (!component) {
        /* Add the component to the _boardData */
        console.log('Component ' + parts[0] + ' not found in '
          + this._board + '/board.json');
        component = {
          type: "component",
          refdes: parts[0],
          name: parts[0],
          description: 'No description provided.'
        };

        this._boardData.push(component);
        missing.push(component);
      }

      if (isPin && !pin) {
        console.log('Pin ' + parts[1] + ' not found under ' + parts[0]
            + ' for ' + this._board + '/board.json');
        pin = {
          type: "pin",
          refdes: svgItem.refdes,
          name: svgItem.refdes,
          component: component.refdes,
          description: 'No description provided.'
        };

        if (!component.pins) {
          component.pins = [];
        }
        component.pins.push(pin);
      }
    }, this);

    /* Fire off a resize */
    this.resize();

    if (missing.length) {
      console.log("Missing items: " + JSON.stringify(missing, null, 2));
    }

    this._calculateSVGElements();
    this._filters.forEach(this._populateFilter, this);
  },

  getDocumentation: function(refdes, type, callback) {
    if (!this.board) {
      callback({
        error: "No board loaded.",
        status: 500
      });
    }

    /* Adjust for optional parameters */

    /* If type is not set, and refdes is set to HTML or MD,
     * set type to refdes and clear refdes. */
    if (!type) {
      if (refdes == "HTML" || refdes == "MD") {
        type = refdes;
        refdes = undefined;
      } else {
        type = "MD"; /* Default to Markdown */
      }
    }

    if (!callback) {
      return;
    }

    var url = this.basePath + "boards/" + this.board + "/";
    if (refdes) {
      var item = this.findComponent(refdes);
      if (item && item.markdown) {
        url += "docs/" + item.markdown;
      } else {
        url += "docs/" + refdes + ".md";
      }
    } else {
      url += "index.md";
    }

    var ironRequest = document.createElement('iron-request');
    ironRequest.send({url: url}).then(function(request) {
      var content;
      if (type && type == 'HTML') {
        try {
          content = this.md.render(request.response);
        } catch (_) {
          callback({
            error: "Unable to parse returned content.",
            status: 500
          });
          return;
        }
      } else {
        content = request.response;
      }

      callback({
        status: 200,
        content: content
      });
    }.bind(this)).catch(function(error) {
      callback({
        error: "Unable to load documentation for " + refdes,
        status: 400
      });
    });
  },

  getInfo: function(refdes) {
    var item = this.findComponent(refdes);
    if (item) {
      return item;
    }

    /* No item found in the _boardData -- see if it exists in the
     * svgElements cache and return just a refdes if so, otherwise
     * return null */
    for (var i = 0; i < this._svgElements.length; i++) {
      if (this._svgElements[i].refdes == refdes) {
        return { refdes: refdes };
      }
    }

    return null;
  },

  getBoards: function(callback) {
    if (!callback) {
      return;
    }

    this.$.boards.send({
      url: this.basePath + "boards.json",
      handleAs: "json"
    }).then(function(request) {
      var boards = request.response,
        results = [];
      if (!boards || !Array.isArray(boards)) {
        return Promise.reject("boards.json did not return any boards.");
      }
      boards.forEach(function(board) {
        results.push({
          name: board.title,
          directory: board.board,
          image: board.board + '/' + board.image
        });
      })

      results = results.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });

      callback(results);
    }.bind(this)).catch(function(error) {
      console.log("Unable to load boards.json");
      callback(new Error(error));
    });
  },

  getKeywords: function(callback) {
    if (!callback) {
      return;
    }

    var keywords = [];

    function buildKeywords(item) {
      if ("keywords" in item) {
        item.keywords.forEach(function(keyword) {
          if (keywords.indexOf(keyword) == -1) {
            keywords.push(keyword);
          }
        });
      }

      return keywords;
    }

    this._boardData.forEach(function(component) {
      if (component.pins) {
        component.pins.forEach(buildKeywords);
      }
      buildKeywords(component);
    });

    callback(keywords.sort());
  },

  getComponents: function(callback) {
    var components = [];
    if (!callback) {
      return;
    }

    this._boardData.forEach(function(component) {
      components.push(component.refdes);
    });

    /* Sort the components, supporting numerical sorting in names */
    components = components.sort(function(a, b) {
      var partsA = a.match(/([^0-9]*)([0-9]*)(.*)/),
        partsB = b.match(/([^0-9]*)([0-9]*)(.*)/),
        results = partsA[1].localeCompare(partsB[1]);
      if (results != 0) {
        return results;
      }
      results = partsA[2] - partsB[2];
      if (results != 0) {
        return results;
      }
      return partsA[3].localeCompare(partsB[3]);
    });

    callback(components);
  },

  attached: function() {
    this.md = window.markdownit({
      html: false,
      xhtmlout: false,
      breaks: false
    });

    /* Element needs to process resize events to rescale if necessary */
    window.addEventListener('resize', this.resize.bind(this));

    /* Async re-size */
    this.async(this.resize);
  }
});
</script>
